# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/showdoc.ipynb (unless otherwise specified).

__all__ = ['is_valid_xml', 'param2JSX', 'np2jsx', 'fmt_sig_param', 'get_sig_section', 'get_type', 'get_base_urls',
           'ShowDoc', 'param2md', 'np2md', 'fmt_sig_param_md', 'get_sig_section_md', 'format_signature_md']

# Cell
from numpydoc.docscrape import ClassDoc, FunctionDoc, Parameter
from fastcore.xtras import get_source_link
from fastcore.foundation import L
from xml.etree import ElementTree as et
import inspect, warnings
from nbdev.showdoc import get_config
from functools import partial
import re

# Cell
_ATTRS_PARAMS=['Parameters', 'Attributes', 'Returns', 'Yields', 'Raises'] # These have parameters
_ATTRS_STR_LIST=['Summary', 'Extended Summary', 'Examples'] # These are lists of strings
def _is_func(obj): return inspect.isfunction(obj)

# Cell
def is_valid_xml(xml:str):
    "Determine if xml is valid or not."
    try: et.fromstring(xml)
    except et.ParseError as e:
        print(f"WARNING: xml not does not parse:{e}")
        return False
    return True

# Cell
def param2JSX(p:Parameter):
    "Format a numpydoc.docscrape.Parameters as JSX components"
    prefix = "<Parameter"
    suffix = " />"
    for a in ['name', 'type', 'desc']:
        val = getattr(p, a)
        if val:
            if a == 'desc':
                desc = '\n'.join(val).encode('unicode_escape').decode('utf-8')
                prefix += f' {a}="{desc}"'
            else: prefix += f' {a}="{val}"'
    return prefix.strip() + suffix

# Cell
def param2md(p:Parameter):
    "Format a numpydoc.docscrape.Parameters as markdown"
    name = p.name if p.name else ""
    typ = p.type if p.type else ""
    desc = '\n'.join(p.desc) if p.desc else ""
    
    if typ:
        return f"- **{name}** (*{typ}*): {desc}"
    else:
        return f"- **{name}**: {desc}"

# Cell
_re_returns = re.compile('\nReturns\n-------\n(.*)', re.DOTALL)

def _esc(s): return s.encode('unicode_escape').decode('utf-8').replace('"', '&#34;')

def _returns(docstring):
    "Parse just the returns section for properties."
    returns = _re_returns.findall(docstring)
    if returns:
        args = returns[0].split('\n    ')
        if len(args) == 2:
            typ,desc=args
            return f'<ParamSection name="Returns">\n<Parameter type="{typ}" desc="{_esc(desc)}" />\n</ParamSection>'
        else: return ''
    else: return ''

def _returns_md(docstring, heading_level=3):
    "Parse just the returns section for properties and return markdown."
    returns = _re_returns.findall(docstring)
    if returns:
        args = returns[0].split('\n    ')
        if len(args) == 2:
            typ, desc = args
            heading_prefix = '#' * heading_level
            return f'\n\n{heading_prefix} Returns\n\n- **{typ}**: {desc}'
        else: return ''
    else: return ''

def _desc(summary): return f'<Description summary="{_esc(summary)}" />'

def _desc_md(summary): return summary

def np2jsx(obj, skip_sections=''):
    "Turn Numpy Docstrings Into JSX components"
    if inspect.isclass(obj): doc = ClassDoc(obj)
    elif _is_func(obj) or inspect.ismethod(obj): doc = FunctionDoc(obj)
    else:
        _summary = inspect.getdoc(obj)
        ret = _returns(_summary) # get the return section if present
        if ret: ret = '\n'+ret
        summary = _re_returns.sub('', _summary) # get rid of the Returns
        return f'{_desc(summary)}{ret}'

    desc_list = []
    for a in _ATTRS_STR_LIST:
        nm = a.replace(' ', '_').lower()
        desc = '\n'.join(doc[a]).encode('unicode_escape').decode('utf-8').replace('"', '&#34;')
        if doc[a]: desc_list.append(f' {nm}="{desc}"')
    desc_props = ''.join(desc_list)
    desc_component = f'<Description{desc_props} />' if desc_props else ''

    jsx_sections = []
    for a in _ATTRS_PARAMS:
        if a not in L(skip_sections):
            params = doc[a]
            if params:
                jsx_params = '\t' + '\n\t'.join([param2JSX(p) for p in params])
                jsx_block = f'<ParamSection name="{a}">\n{jsx_params}\n</ParamSection>'
                jsx_sections.append(jsx_block)

    return desc_component+ '\n' + '\n'.join(jsx_sections)

# Cell
def np2md(obj, skip_sections='', heading_level=3):
    "Turn Numpy Docstrings Into clean markdown"
    if inspect.isclass(obj): doc = ClassDoc(obj)
    elif _is_func(obj) or inspect.ismethod(obj): doc = FunctionDoc(obj)
    else:
        _summary = inspect.getdoc(obj)
        ret = _returns_md(_summary, heading_level=heading_level) # get the return section if present
        summary = _re_returns.sub('', _summary) # get rid of the Returns
        return f'{_desc_md(summary)}{ret}'

    # Build description from summary and extended summary (but not Examples)
    desc_parts = []
    for a in ['Summary', 'Extended Summary']:
        content = doc[a]
        if content:
            desc_parts.extend(content)
    
    desc_component = '\n\n'.join(desc_parts) if desc_parts else ''

    # Build parameter sections - only include sections that have actual parameters
    md_sections = []
    heading_prefix = '#' * heading_level
    
    for a in _ATTRS_PARAMS:
        if a not in L(skip_sections):
            params = doc[a]
            if params and len(params) > 0:  # Only include if there are actual parameters
                md_params = [param2md(p) for p in params]
                if md_params:  # Double check that we have formatted parameters
                    section_title = f'{heading_prefix} {a}\n\n'
                    section_content = '\n'.join(md_params)
                    md_sections.append(section_title + section_content)

    # Handle Examples section specially
    if 'Examples' not in L(skip_sections) and doc['Examples']:
        examples_content = '\n'.join(doc['Examples'])
        if examples_content.strip():
            examples_section = f'{heading_prefix} Examples\n\n{examples_content}'
            md_sections.append(examples_section)

    sections_md = '\n\n'.join(md_sections)
    
    if desc_component and sections_md:
        return f'{desc_component}\n\n{sections_md}'
    elif desc_component:
        return desc_component
    elif sections_md:
        return sections_md
    else:
        return ''

# Cell
def fmt_sig_param(p:inspect.Parameter):
    "Format inspect.Parameters as JSX components."
    name = str(p) if str(p).startswith('*') else p.name
    prefix = f'<SigArg name="{name}" '

    if p.annotation != inspect._empty:
        prefix += f'type="{p.annotation.__name__}" '
    if p.default != inspect._empty:
        prefix += f'default="{p.default}" '

    return prefix + "/>"

# Cell
def fmt_sig_param_md(p:inspect.Parameter):
    "Format inspect.Parameters as markdown."
    name = str(p) if str(p).startswith('*') else p.name
    
    parts = [f"`{name}`"]
    
    if p.annotation != inspect._empty:
        try:
            type_name = p.annotation.__name__
        except AttributeError:
            type_name = str(p.annotation)
        parts.append(f"(*{type_name}*)")
    
    if p.default != inspect._empty:
        parts.append(f"= `{p.default}`")
    
    return ' '.join(parts)

# Cell
def _format_param_type(annotation, type_replacements=None):
    "Format a parameter annotation, applying type replacements if provided."
    if annotation == inspect._empty:
        return None
    
    # Handle basic types (str, int, float, etc.) which show as <class 'str'>
    if isinstance(annotation, type):
        type_str = annotation.__name__
    else:
        type_str = str(annotation)
        # Clean up the type string (remove 'typing.' prefix, etc.)
        type_str = type_str.replace('typing.', '')
    
    # Apply custom replacements
    if type_replacements:
        for old, new in type_replacements.items():
            type_str = type_str.replace(old, new)
    
    return type_str

def _format_single_param(p, type_replacements=None, param_overrides=None):
    "Format a single parameter with optional type replacements and explicit overrides."
    name = p.name
    
    # Check for explicit override for this parameter
    if param_overrides and name in param_overrides:
        override = param_overrides[name]
        # If override is a string, use it as the complete param representation
        if isinstance(override, str):
            return override
        # If override is a dict, use it for type and/or default
        override_type = override.get('type')
        override_default = override.get('default')
    else:
        override_type = None
        override_default = None
    
    # Handle *args and **kwargs
    if p.kind == inspect.Parameter.VAR_POSITIONAL:
        name = f"*{name}"
    elif p.kind == inspect.Parameter.VAR_KEYWORD:
        name = f"**{name}"
    
    parts = [name]
    
    # Add type annotation (use override if provided)
    if override_type is not None:
        if override_type:  # Only add if non-empty string
            parts.append(f": {override_type}")
    else:
        type_str = _format_param_type(p.annotation, type_replacements)
        if type_str:
            parts.append(f": {type_str}")
    
    # Add default value (use override if provided)
    if override_default is not None:
        if override_default:  # Only add if non-empty string
            parts.append(f" = {override_default}")
    elif p.default != inspect._empty:
        default_str = repr(p.default)
        # Shorten very long default values
        if len(default_str) > 50:
            default_str = default_str[:47] + "..."
        parts.append(f" = {default_str}")
    
    return ''.join(parts)

def format_signature_md(obj, name, spoofstr=None, ignore_params=None, type_replacements=None, param_overrides=None):
    "Format a function/class signature as clean, readable markdown."
    if spoofstr is not None:
        return f"```python\n{name}({spoofstr})\n```"
    
    if not inspect.isclass(obj) and not _is_func(obj) and not inspect.ismethod(obj):
        return ""
    
    try:
        sig = inspect.signature(obj)
    except:
        return ""
    
    # Filter out ignored params
    ignore_set = set(ignore_params or [])
    params = [p for p in sig.parameters.values() if p.name not in ignore_set]
    
    if not params:
        return f"```python\n{name}()\n```"
    
    # Format each parameter
    param_strs = [_format_single_param(p, type_replacements, param_overrides) for p in params]
    
    # For short signatures (few params, short total length), keep on one line
    one_line = f"{name}({', '.join(param_strs)})"
    if len(params) <= 2 and len(one_line) < 70:
        return f"```python\n{one_line}\n```"
    
    # For longer signatures, format each parameter on its own line
    param_lines = [f"    {ps}," for ps in param_strs]
    
    # Remove trailing comma from last param
    if param_lines:
        param_lines[-1] = param_lines[-1].rstrip(',')
    
    formatted_params = '\n'.join(param_lines)
    return f"```python\n{name}(\n{formatted_params}\n)\n```"

# Cell
def get_sig_section(obj, spoofstr=None):
    "Get JSX section from the signature of a class or function consisting of all of the argument. Optionally replace signature with `spoofstr`"
    if spoofstr is None:
        if not inspect.isclass(obj) and not _is_func(obj) and not inspect.ismethod(obj): return ""
        try:
            sig = inspect.signature(obj)
        except:
            return ''
        params = sig.parameters.items()
        jsx_params = [fmt_sig_param(p) for _, p in params]
    else:
        jsx_params = [f'<SigArg name="{spoofstr}" />']
    return "<SigArgSection>\n" + ''.join(jsx_params) +"\n</SigArgSection>"

# Cell
def get_sig_section_md(obj, spoofstr=None, heading_level=3):
    "Get markdown section from the signature of a class or function consisting of all of the arguments. Optionally replace signature with `spoofstr`"
    if spoofstr is None:
        if not inspect.isclass(obj) and not _is_func(obj) and not inspect.ismethod(obj): return ""
        try:
            sig = inspect.signature(obj)
        except:
            return ''
        params = sig.parameters.items()
        if not params:
            return ''
        md_params = [fmt_sig_param_md(p) for _, p in params]
    else:
        md_params = [f"`{spoofstr}`"]
    
    if not md_params:
        return ''
    
    heading_prefix = '#' * heading_level
    return f"{heading_prefix} Parameters\n\n" + ', '.join(md_params)

# Cell
def get_type(obj):
    "Return type of object as a either 'method', 'function', 'class' or `None`."
    typ = None
    if inspect.ismethod(obj): return 'method'
    if hasattr(obj, 'fget'): return 'property'
    if _is_func(obj):
        try:
            sig = inspect.signature(obj)
            if 'self' in sig.parameters: typ = 'method'
            else: typ = 'function'
        except ValueError:
            return 'function'
    elif inspect.isclass(obj): typ = 'class'
    return typ

# Cell
def get_base_urls(warn=False, param='module_baseurls') -> dict:
    "Get baseurls from config file"
    cfg = get_config()
    if param not in cfg:
        if warn: warnings.warn(f"Did not find `{param}` setting in {cfg.config_file}")
        return {}
    return dict([b.split('=', 1) for b in cfg.module_baseurls.split('\n')])

# Cell
#hide
def _get_name(var):
    try:
        callers_local_vars = inspect.currentframe().f_back.f_back.f_back.f_locals.items()
        return [var_name for var_name, var_val in callers_local_vars if var_val is var][0]
    except:
        return None

# Cell
#hide
def _get_mf_obj(obj):
    "Get decorator partials for Metaflow."
    if type(obj) == partial and hasattr(obj, 'args'):
        args=getattr(obj, 'args')
        if args:
            arg = args[0]
            if hasattr(arg, '__name__'):
                nm = arg.__name__
                if nm and 'decorator' in nm.lower():
                    newnm = _get_name(obj)
                    arg.__newname__ = newnm if newnm else nm
                    arg.__ismfdecorator__ = True
                    return arg
        else:
            return obj.func
    else:
        return obj

# Cell
class ShowDoc:
    def __init__(self, obj,
                 hd_lvl=None, # override heading level
                 name=None, # override name of object ex: '@mydecorator'
                 objtype=None, # override type of object. ex: 'decorator'
                 module_nm=None, #override module name. ex: 'fastai.vision'
                 decorator=False, #same as setting `objtype` = 'decorator'
                 spoofstr=None, # Spoof the signature
                 show_import=False, #show import statement
                 skip_sections='', # list of sections to skip, one or more of 'Parameters', 'Attributes', 'Returns', 'Yields', 'Raises'
                 type_override=None, # override type of object in the final output. ex: 'decorator'
                 markdown=True, # Generate markdown instead of JSX
                 show_signature=True, # set to False to hide the signature block entirely
                 sig_ignore_params=None, # list of param names to exclude from signature, e.g. ['self', '_internal']
                 sig_type_replacements=None, # dict of type string replacements, e.g. {'metaflow_extensions.outerbounds...': 'Config'}
                 sig_param_overrides=None # dict to override specific params, e.g. {'logger_fn': {'type': 'Callable', 'default': 'None'}}
                ):
        "Construct the html, JSX, and markdown representation for a particular object."
        self.spoofstr = spoofstr
        self.show_import = show_import
        self.markdown = markdown
        self.show_signature = show_signature
        self.sig_ignore_params = sig_ignore_params or []
        self.sig_type_replacements = sig_type_replacements or {}
        self.sig_param_overrides = sig_param_overrides or {}
        if decorator: objtype = 'decorator'
        self.obj = _get_mf_obj(obj)
        #special handling for metaflow decorators
        if hasattr(self.obj, '__ismfdecorator__'):
            decorator = True
            objtype = 'decorator'
            name = self.obj.__newname__
        self.decorator = decorator
        self.typ = get_type(self.obj) if not objtype else objtype
        # if not self.typ: raise ValueError(f'Can only parse a class or a function, but got a {type(self.obj)}')
        
        self.type_override = type_override
        if self.typ == 'method': default_nm = self.obj.__qualname__
        elif self.typ == 'property':
            default_nm = self.obj.fget.__qualname__
            module_nm = inspect.getmodule(self.obj.fget).__name__
        else: default_nm = self.obj.__name__

        self.objnm = default_nm if not name else name

        self.modnm = inspect.getmodule(self.obj).__name__ if not module_nm else module_nm

        if hd_lvl: self.hd_lvl = hd_lvl
        elif self.typ in ['method', 'property']: self.hd_lvl = 4
        else: self.hd_lvl = 3
        self.link_suffix = get_source_link(self.obj)
        
        # Generate both JSX and markdown docs
        self.npdocs = np2jsx(self.obj, skip_sections=skip_sections)
        self.npdocs_md = np2md(self.obj, skip_sections=skip_sections, heading_level=self.hd_lvl + 1)

    def _repr_html_(self):
        "This method controls what is displayed in Jupyter Notebooks."
        if self.markdown:
            return self.markdown_output
        else:
            return f'<HTMLRemove>\n{self.nbhtml}\n</HTMLRemove>\n{self.jsx}'

    @property
    def nbhtml(self):
        "HTML to be shown in the notebook"
        name=self.objnm
        _type = self.type_override if self.type_override else self.typ
        if self.decorator and not name.startswith('@'):name = '@' + name
        hd_prefix = f'<h{self.hd_lvl}> <code>{_type}</code> <span style="color:Brown">{name}</span> <em>{self._html_signature}</em>'
        if self.src_link: hd_prefix += f'<a href="{self.src_link}" style="float:right">[source]</a>'
        hd_prefix += f'</h{self.hd_lvl}>'
        if self.show_import: hd_prefix += f'<strong>{self.modnm}</strong>'
        if self._html_docstring: hd_prefix += f'<p>{self._html_docstring}</p>'
        return hd_prefix

    @property
    def _html_docstring(self):
        "Docstrings in HTML format"
        doc = inspect.getdoc(self.obj)
        if not doc: return ''
        return '<blockquote>'+doc.replace(' ', '&nbsp;').replace('\n', '<br>').strip()+'</blockquote>'

    @property
    def _html_signature(self):
        if self.decorator: sig = '(...)'
        elif self.spoofstr is not None: sig = self.spoofstr
        else:
            try: sig = str(inspect.signature(self.obj))
            except: sig = ''
        return sig

    @property
    def jsx(self):
        "Returns the JSX components."
        nm = f'<DocSection type="{self.typ}" name="{self.objnm}" module="{self.modnm}" show_import="{self.show_import}" heading_level="{self.hd_lvl}"{self._src_link_attr}>'
        spoof = '...' if self.decorator else self.spoofstr
        sp = get_sig_section(self.obj, spoofstr=spoof)
        return f'{nm}\n{sp}\n' + self.npdocs + '\n</DocSection>'

    @property
    def markdown_output(self):
        "Returns clean markdown documentation."
        name = self.objnm
        if self.decorator and not name.startswith('@'):
            name = '@' + name
        
        # Create the main heading
        heading_prefix = '#' * self.hd_lvl
        _type = self.type_override if self.type_override else self.typ
        heading = f"{heading_prefix} {_type.title()}: `{name}`"
        
        # Add formatted signature (if enabled)
        if self.show_signature:
            if self.decorator:
                sig_block = f"```python\n{name}(...)\n```"
            else:
                sig_block = format_signature_md(
                    self.obj, name, 
                    spoofstr=self.spoofstr,
                    ignore_params=self.sig_ignore_params,
                    type_replacements=self.sig_type_replacements,
                    param_overrides=self.sig_param_overrides
                )
            
            if sig_block:
                heading += f"\n\n{sig_block}"
        
        # Add source link if available
        if self.src_link:
            heading += f"\n\n[Source]({self.src_link})"
        
        # Add import statement if requested
        if self.show_import:
            heading += f"\n\n**Module:** `{self.modnm}`"
        
        # Combine all parts - only include docstring content, no duplicate signature parameters
        parts = [heading]
        if self.npdocs_md:
            parts.append(self.npdocs_md)
        
        return '\n\n'.join(parts)

    @property
    def src_link(self):
        "Construct the full link if it can be found."
        base_url = get_base_urls().get(self.modnm.split('.')[0])
        if base_url: return base_url + self.link_suffix
        else: return None

    @property
    def _src_link_attr(self):
        "JSX attribute if full link is found, otherwhise empty string."
        if not self.src_link: return ''
        else: return f' link="{self.src_link}"'